const JSX =
<h1>Hello JSX!</h1>
;
<!-- //should be insisde ine element  -->
const JSX=
<div>
  <h1></h1>
  <p></p>
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</div>
; const JSX = (
<div>
  {/*this is me learning how to comment inside a jsx in react js*/}
  <h1>This is a block of JSX</h1>
  <p>Here's a subtitle</p>
</div>
); ReactDOM offers a simple method to render React elements to the DOM which
looks like this: ReactDOM.render(componentToRender, targetNode), where the first
argument is the React element or component that you want to render, and the
second argument is the DOM node that you want to render the component to.
ReactDOM offers a simple method to render React elements to the DOM which looks
like this: ReactDOM.render(componentToRender, targetNode), where the first
argument is the React element or component that you want to render, and the
second argument is the DOM node that you want to render the component to. As you
would expect, ReactDOM.render() must be called after the JSX element
declarations, just like how you must declare variables before using them. The
code editor has a simple JSX component. Use the ReactDOM.render() method to
render this component to the page. You can pass defined JSX elements directly in
as the first argument and use document.getElementById() to select the DOM node
to render them to. There is a div with id='challenge-node' available for you to
use. Make sure you don't change the JSX constant. const JSX = (
<div id="challenge-node">
  <h1>Hello World</h1>
  <p>Lets render this to the DOM</p>
</div>
); // Add your code below this line ReactDOM.render(JSX,
document.getElementById('challenge-node'));



Adding classes in JSXconst JSX = (
  <div className="myDiv">
    <h1>Add a class to this div</h1>
  </div>
);


there is always a closing tag in jsx we cant ignore and thus it is important to know the rules :
here are the rules :
In HTML, almost all tags have both an opening and closing tag: <div></div>; the closing tag always has a forward slash before the tag name that you are closing. However, there are special instances in HTML called void elements, or elements that don‚Äôt require both an opening and closing tag before another element can start.

For example the line-break tag can be written as <br> or as <br />, but should never be written as <br></br>, since it doesn't contain any content.

In JSX, the rules are a little different. Any JSX element can be written with a self-closing tag, and every element must be closed. The line-break tag, for example, must always be written as <br /> 
in order to be valid JSX that can be transpiled. A <div>, on the other hand, can be written as <div /> or <div></div>.
 The difference is that in the first syntax version there is no way to include anything in the <div />. 
You will see in later challenges that this syntax is useful when rendering React components.

const JSX = (
  <div>
    <h2>Welcome to React!</h2> <br/>
    <p>Be sure to close all tags!</p>
    <hr/>
  </div>
);


creating components in react js 
1 way;; statless way Defining a component in this way creates a stateless functional component. The concept of state in an application will be covered in later challenges. For now, think of a stateless component as one that can receive data and render it, but does not manage or track changes to that data. (We'll cover the second way to create a React component in the next challenge.)
const MyComponent = function() {
  // Change code below this line
return(
 <div>Hello My name is Srijan Kumar</div>
);
  // Change code above this line
}

SECOND WAY TO DEFINE THE COMPONENT:
The other way to define a React component is with the ES6 class syntax.
 In the following example, Kitten extends React.Component:

class Kitten extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <h1>Hi</h1>
    );
  }
}
 in simple words :
 You're creating a React component using a class.

üß± Breakdown step-by-step:
jsx
Copy
Edit
class Kitten extends React.Component {
This creates a new component called Kitten.

It uses class syntax.

It extends React.Component, which means it's getting all the features of a React component (like rendering, state, etc.).

jsx
Copy
Edit
  constructor(props) {
    super(props);
  }
This is the constructor ‚Äì it runs when the component is created.

props = data passed to the component.

super(props) calls the constructor of the parent class (React.Component) to set up the component properly.

jsx
Copy
Edit
  render() {
    return (
      <h1>Hi</h1>
    );
  }
}
This is the render method ‚Äì it decides what shows up on the screen.

In this case, it just shows <h1>Hi</h1>.

üß† In short:
You're making a component named Kitten.

It displays the word ‚ÄúHi‚Äù.




class MyComponent extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    // Change code below this line
    return(
       <div>
       <h1>Hello React!</h1>
       </div>
    );
    // Change code above this line
  }
};


To compose these components together, you could create an App parent component which renders each of these three components as children. To render a component as a child in a React component, you include the component name written as a custom HTML tag in the JSX. For example, in the render method you could write:

return (
 <App>
  <Navbar />
  <Dashboard />
  <Footer />
 </App>
)
When React encounters a custom HTML tag that references another component (a component name wrapped in < /> like in this example), it renders the markup for that component in the location of the tag. This should illustrate the parent/child relationship between the App component and the Navbar, Dashboard, and Footer.

Rendering one component inside the other :
const ChildComponent = () => {
  return (
    <div>
      <p>I am the child</p>
    </div>
  );
};


class ParentComponent extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h1>I am the parent</h1>
        { /* Change code below this line */ }

              <ChildComponent />
             
        { /* Change code above this line */ }
      </div>
    );
  }
};

NESTINGG THE COMPONENTS INSIDE EACH OTHER \
const TypesOfFruit = () => {
  return (
    <div>
      <h2>Fruits:</h2>
      <ul>
        <li>Apples</li>
        <li>Blueberries</li>
        <li>Strawberries</li>
        <li>Bananas</li>
      </ul>
    </div>
  );
};

const Fruits = () => {
  return (
    <div>
      { /* Change code below this line */ }
     <TypesOfFruit/>
      { /* Change code above this line */ }
    </div>
  );
};

class TypesOfFood extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h1>Types of Food:</h1>
        { /* Change code below this line */ }         
              <Fruits/>      
        { /* Change code above this line */ }
      </div>
    );
  }
};

class Fruits extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h2>Fruits:</h2>
        { /* Change code below this line */ }
    <NonCitrus/>
    <Citrus/>
        { /* Change code above this line */ }
      </div>
    );
  }
};

class TypesOfFood extends React.Component {
  constructor(props) {
     super(props);
  }
  render() {
    return (
      <div>
        <h1>Types of Food:</h1>
        { /* Change code below this line */ }
       <Fruits/>
        { /* Change code above this line */ }
        <Vegetables />
      </div>
    );
  }
};


Render a Class Component to the DOM
You may remember using the ReactDOM API in an earlier challenge to render JSX elements to the DOM. The process for rendering React components will look very similar. The past few challenges focused on components and composition, so the rendering was done for you behind the scenes. However, none of the React code you write will render to the DOM without making a call to the ReactDOM API.

Here's a refresher on the syntax: ReactDOM.render(componentToRender, targetNode). The first argument is the React component that you want to render. The second argument is the DOM node that you want to render that component within.

React components are passed into ReactDOM.render() a little differently than JSX elements. For JSX elements, you pass in the name of the element that you want to render. However, for React components, you need to use the same syntax as if you were rendering a nested component, for example ReactDOM.render(<ComponentToRender />, targetNode). You use this syntax for both ES6 class components and functional components.

Both the Fruits and Vegetables components are defined for you behind the scenes. Render both components as children of the TypesOfFood component, then render TypesOfFood to the DOM. There is a div with id='challenge-node' available for you to use.


class TypesOfFood extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div id="challenge-node">
        <h1>TypesOfFood:</h1>
        {/* Change code below this line */}
          <Fruits/>
          <Vegetables/>
        
        {/* Change code above this line */}
      </div>
    );
  }
};

// Change code below this line
    ReactDOM.render(<TypesOfFood/>,document.getElementById('challenge-node'));


BUILDIND MY FIRST  REACT COMPONENT:
//always make sure you use camel case as js is case sensitive 

// Change code below this line
class MyComponent extends React.Component{
  constructor(props){
    super(props)}
  render(){
     return(
     <div id="challenge-node">
     <h1>My First React Component!</h1>


     </div>

     )
  }
};
ReactDOM.render(<MyComponent/>,document.getElementById('challenge-node'))

//PROPS

Props are like data you send from one component (the parent) to another (the child).

üëâ Think of it like this:

You have a parent component called Calendar

You want to give some data (like today‚Äôs date) to a child component called CurrentDate

You do that using props
You are:
Passing today‚Äôs date from Calendar ‚û°Ô∏è to CurrentDate
Displaying that date inside a <p> tag in CurrentDate

    1. Here's your child component CurrentDate:
const CurrentDate = (props) => {
  return (
    <div>
      <p>The current date is: {props.date}</p>
    </div>
  );
};
2. Here's your parent component Calendar:
You need to pass the date as a prop using date={Date()}:

const Calendar = () => {
  return (
    <div>
      <h3>What date is it?</h3>
      <CurrentDate date={Date()} />
    </div>
  );
};
3. Rendering it:
ReactDOM.render(<Calendar />, document.getElementById('challenge-node'));


//final code for passing props 
const CurrentDate = (props) => {
  return (
    <div>
      { /* Change code below this line */ }
      <p>The current date is: {props.date}</p>
      { /* Change code above this line */ }
    </div>
  );
};

class Calendar extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h3>What date is it?</h3>
        { /* Change code below this line */ }
        <CurrentDate date={Date()}/>
        { /* Change code above this line */ }
      </div>
    );
  }
};


//passing arrays as props :

const List = (props) => {
  { /* Change code below this line */ }
  return <p>{props.tasks.join(', ')}</p>
  { /* Change code above this line */ }
};

class ToDo extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h1>To Do Lists</h1>
        <h2>Today</h2>
        { /* Change code below this line */ }
      <List tasks={["walk dog","workout"]}/>
        <h2>Tomorrow</h2>
        <List tasks={["walk dog","workout","eat","sleep","code","repeat"]}/>
        { /* Change code above this line */ }
      </div>
    );
  }
};


//setting up default props
const ShoppingCart = (props) => {
  return (
    <div>
      <h1>Shopping Cart Components {props.items}</h1>
    </div>
  )
};
// Change code below this line
ShoppingCart.defaultProps ={
  items:0
};

//Override Default Props
The ability to set default props is a useful feature in React. 
The way to override the default props is to explicitly set the prop values for a component.
const Items = (props) => {
  return <h1>Current Quantity of Items in Cart: {props.quantity}</h1>
}

Items.defaultProps = {
  quantity: 0
}

class ShoppingCart extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    { /* Change code below this line */ }
    return <Items quantity={10} />
    { /* Change code above this line */ }
  }
};


<!-- Use PropTypes to Define the Props You Expect -->

 this is done in the same way as the default prop is defined :
 const Items = (props) => {
  return <h1>Current Quantity of Items in Cart: {props.quantity}</h1>
};

// Change code below this line
Items.propTypes={quantity:PropTypes.number.isRequired}
// Change code above this line

Items.defaultProps = {
  quantity: 0
};

class ShoppingCart extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return <Items />
  }
};


<!-- Access Props Using this.props -->
 <!-- for es6 component definition we use the this keyword  -->
class App extends React.Component {
  constructor(props) {
    super(props);

  }
  render() {
    return (
        <div>
            { /* Change code below this line */ }
            <Welcome name="srijan"/>
            { /* Change code above this line */ }
        </div>
    );
  }
};

class Welcome extends React.Component {
  constructor(props) {
    super(props);

  }
  render() {
    return (
        <div>
          { /* Change code below this line */ }
          <p>Hello, <strong>{this.props.name}
          </strong>!</p>
          { /* Change code above this line */ }
        </div>
    );
  }
};


<!-- Review Using Props with Stateless Functional Components -->
const Camper=(props)=>{
   return(
     <p>{props.name}</p>
   )
}
Camper.defaultProps={
  name:"CamperBot"
}
Camper.propTypes={
  name:PropTypes.string.isRequired
}


class CampSite extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <Camper/>
      </div>
    );
  }
};
// Change code below this line
ReactDOM.render(<CampSite />, document.getElementById('root'));


//STATES IN REACT JS FCC -free code camp.org
Create a Stateful Component
One of the most important topics in React is state. State consists of any data your application needs to know about, that can change over time. You want your apps to respond to state changes and present an updated UI when necessary. React offers a nice solution for the state management of modern web applications.

You create state in a React component by declaring a state property on the component class in its constructor. This initializes the component with state when it is created. The state property must be set to a JavaScript object. Declaring it looks like this:

this.state = {

}
You have access to the state object throughout the life of your component. You can update it, render it in your UI, and pass it as props to child components. The state object can be as complex or as simple as you need it to be. Note that you must create a class component by extending React.Component in order to create state like thi

class StatefulComponent extends React.Component {
  constructor(props) {
    super(props);
    // Only change code below this line
   this.state={
     firstName:"Srijan"
   }
    // Only change code above this line
  }
  render() {
    return (
      <div>
        <h1>{this.state.firstName}</h1>
      </div>
    );
  }
};

<!-- Render State in the User Interface -->
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'freeCodeCamp'
    }
  }
  render() {
    return (
      <div>
        { /* Change code below this line */ }
          <h1>{this.state.name}</h1>
        { /* Change code above this line */ }
      </div>
    );
  }
};

<!-- Render State in the User Interface Another Way
There is another way to access state in a component. In the render() method, before the return statement, you can write JavaScript directly. For example, you could declare functions, access data from state or props, perform computations on this data, and so on. Then, you can assign any data to variables, which you have access to in the return statement. -->
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'freeCodeCamp'
    }
  }
  render() {
    // Change code below this line
     const name=this.state.name;
    // Change code above this line
 
    return (
      <div>
        { /* Change code below this line */ }
     <h1>{name}</h1>
        { /* Change code above this line */ }
      </div>
    );
  }
};


<!-- Set State with this.setState
The previous challenges covered component state and how to initialize state in the constructor. There is also a way to change the component's state. React provides a method for updating component state called setState. You call the setState method within your component class like so: this.setState(), passing in an object with key-value pairs. The keys are your state properties and the values are the updated state data. For instance, if we were storing a username in state and wanted to update it, it would look like this:

this.setState({
  username: 'Lewis'
}); -->
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'Initial State'
    };
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    // Change code below this line
      this.setState({
        name:"React Rocks!"
      })
    // Change code above this line
  }
  render() {
    return (
      <div>
        <button onClick={this.handleClick}>Click Me</button>
        <h1>{this.state.name}</h1>
      </div>
    );
  }
};

<!-- Bind 'this' to a Class Method -->
 Bind 'this' to a Class Method
In addition to setting and updating state, you can also define methods for your component class. A class method typically needs to use the this keyword so it can access properties on the class (such as state and props) inside the scope of the method. There are a few ways to allow your class methods to access this.

One common way is to explicitly bind this in the constructor so this becomes bound to the class methods when the component is initialized. You may have noticed the last challenge used this.handleClick = this.handleClick.bind(this) for its handleClick method in the constructor. Then, when you call a function like this.setState() within your class method, this refers to the class and will not be undefined.

Note: The this keyword is one of the most confusing aspects of JavaScript but it plays an important role in React. Although its behavior here is totally normal, these lessons aren't the place for an in-depth review of this so please refer to other lessons if the above is confusing!
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      text: "Hello"
    };
    // Change code below this line
      this.handleClick=this.handleClick.bind(this)
    // Change code above this line
  }
  handleClick() {
    this.setState({
      text: "You clicked!"
    });
  }
  render() {
    return (
      <div>
        { /* Change code below this line */ }
        <button onClick={this.handleClick}>Click Me!</button>
        { /* Change code above this line */ }
        <h1>{this.state.text}</h1>
      </div>
    );
  }
};


<!-- Use State to Toggle an Element
Sometimes you might need to know the previous state when updating the state. However, state updates may be asynchronous - this means React may batch multiple setState() calls into a single update. This means you can't rely on the previous value of this.state or this.props when calculating the next value. So, you should not use code like this:

this.setState({
  counter: this.state.counter + this.props.increment
});
Instead, you should pass setState a function that allows you to access state and props. Using a function with setState guarantees you are working with the most current values of state and props. This means that the above should be rewritten as:

this.setState((state, props) => ({
  counter: state.counter + props.increment
}));
You can also use a form without props if you need only the state:

this.setState(state => ({
  counter: state.counter + 1
})); -->
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      visibility: false
    };
    // Bind the method
    this.toggleVisibility = this.toggleVisibility.bind(this);
  }

  // Define the method and CLOSE it properly
  toggleVisibility() {
    this.setState((pstate) => ({ 
      visibility: !pstate.visibility 
    }));
  } // <-- This closing brace was missing

  render() {
    if (this.state.visibility) {
      return (
        <div>
          <button onClick={this.toggleVisibility}>Click Me</button>
          <h1>Now you see me!</h1>
        </div>
      );
    } else {
      return (
        <div>
          <button onClick={this.toggleVisibility}>Click Me</button>
        </div>
      );
    }
  }
}